#!/usr/bin/env python3
"""
Compile Radio.garden places to binary format for ESP32 flash storage.

Downloads all ~12,500 places from Radio.garden API and serializes them
to a compact binary format that can be loaded into LittleFS on the ESP32.

Output files:
  - places.bin: Binary database for LittleFS (upload to ESP32 data partition)
  - places_info.h: C header with metadata (place count, struct definition)

Binary format:
  Header (16 bytes):
    - Magic: "RGPL" (4 bytes)
    - Version: uint16 (2 bytes)
    - Place count: uint32 (4 bytes)
    - Reserved: 6 bytes

  Each place (52 bytes):
    - id: char[16] (null-padded Radio.garden place ID)
    - lat_x100: int16 (latitude * 100, e.g. 48.21° → 4821)
    - lon_x100: int16 (longitude * 100)
    - name: char[28] (null-padded city name, UTF-8 truncated)
    - country: char[4] (ISO country code, null-padded)

Usage:
    python compile_places.py [--output-dir ../esp32/data]
"""

import argparse
import struct
import sys
from pathlib import Path

import requests

# Radio.garden API
PLACES_URL = "http://radio.garden/api/ara/content/places"

# Binary format constants
MAGIC = b"RGPL"
VERSION = 1
PLACE_STRUCT_SIZE = 52  # bytes per place
HEADER_SIZE = 16


def fetch_places() -> list[dict]:
    """Fetch all places from Radio.garden API."""
    print("Fetching places from Radio.garden...")

    session = requests.Session()
    session.headers.update({
        "Accept": "application/json",
        "User-Agent": "RadioWall/1.0"
    })

    resp = session.get(PLACES_URL, timeout=30)
    resp.raise_for_status()

    places = resp.json()["data"]["list"]
    print(f"  Downloaded {len(places)} places")
    return places


def encode_place(place: dict) -> bytes:
    """Encode a single place to binary format (52 bytes)."""
    place_id = place["id"][:15].encode("utf-8")  # Max 15 chars + null

    # Radio.garden geo is [longitude, latitude] - careful!
    lon = place["geo"][0]
    lat = place["geo"][1]

    # Scale to int16 (±327.67 range with 0.01° precision)
    lat_x100 = int(round(lat * 100))
    lon_x100 = int(round(lon * 100))

    # Clamp to int16 range (shouldn't happen for valid coords)
    lat_x100 = max(-32767, min(32767, lat_x100))
    lon_x100 = max(-32767, min(32767, lon_x100))

    # City name - truncate to 27 chars + null
    name = place.get("title", "Unknown")[:27].encode("utf-8", errors="replace")

    # Country code
    country = place.get("country", "??")[:3].encode("utf-8", errors="replace")

    # Pack: 16s = char[16], h = int16, 28s = char[28], 4s = char[4]
    return struct.pack(
        "<16shh28s4s",
        place_id.ljust(16, b"\x00"),
        lat_x100,
        lon_x100,
        name.ljust(28, b"\x00"),
        country.ljust(4, b"\x00"),
    )


def write_binary(places: list[dict], output_path: Path):
    """Write places to binary file."""
    print(f"Writing {output_path}...")

    with open(output_path, "wb") as f:
        # Header
        header = struct.pack(
            "<4sHI6s",
            MAGIC,
            VERSION,
            len(places),
            b"\x00" * 6,  # Reserved
        )
        f.write(header)

        # Places
        for place in places:
            f.write(encode_place(place))

    size_kb = output_path.stat().st_size / 1024
    print(f"  Written {size_kb:.1f} KB ({len(places)} places)")


def write_header(places: list[dict], output_path: Path):
    """Write C header file with metadata."""
    print(f"Writing {output_path}...")

    content = f'''\
/**
 * Radio.garden places database metadata
 *
 * Auto-generated by compile_places.py
 * Do not edit manually!
 */

#ifndef PLACES_INFO_H
#define PLACES_INFO_H

#include <stdint.h>

// Database info
#define PLACES_DB_MAGIC     "RGPL"
#define PLACES_DB_VERSION   {VERSION}
#define PLACES_COUNT        {len(places)}
#define PLACES_STRUCT_SIZE  {PLACE_STRUCT_SIZE}
#define PLACES_HEADER_SIZE  {HEADER_SIZE}

// Place structure (packed, {PLACE_STRUCT_SIZE} bytes)
typedef struct __attribute__((packed)) {{
    char id[16];        // Radio.garden place ID
    int16_t lat_x100;   // Latitude * 100
    int16_t lon_x100;   // Longitude * 100
    char name[28];      // City name (UTF-8, null-terminated)
    char country[4];    // Country code
}} Place;

// Verify struct packing
static_assert(sizeof(Place) == PLACES_STRUCT_SIZE, "Place struct size mismatch");

#endif // PLACES_INFO_H
'''

    output_path.write_text(content)
    print(f"  Written header with {len(places)} places defined")


def print_sample(places: list[dict], n: int = 5):
    """Print sample places for verification."""
    print(f"\nSample places (first {n}):")
    for place in places[:n]:
        lat = place["geo"][1]
        lon = place["geo"][0]
        print(f"  {place['id']:12s} | {place['title']:20s} | {place['country']:15s} | ({lat:.2f}, {lon:.2f})")


def main():
    parser = argparse.ArgumentParser(
        description="Compile Radio.garden places to binary format for ESP32"
    )
    parser.add_argument(
        "--output-dir", "-o",
        type=Path,
        default=Path(__file__).parent.parent / "esp32" / "data",
        help="Output directory (default: ../esp32/data)"
    )
    parser.add_argument(
        "--header-dir",
        type=Path,
        default=None,
        help="Directory for C header file (default: ../esp32/src)"
    )
    parser.add_argument(
        "--sample", "-s",
        type=int,
        default=5,
        help="Number of sample places to print (default: 5)"
    )
    args = parser.parse_args()

    # Set header dir default
    if args.header_dir is None:
        args.header_dir = Path(__file__).parent.parent / "esp32" / "src"

    # Create output directories
    args.output_dir.mkdir(parents=True, exist_ok=True)
    args.header_dir.mkdir(parents=True, exist_ok=True)

    # Fetch and process
    places = fetch_places()
    print_sample(places, args.sample)

    # Write outputs
    write_binary(places, args.output_dir / "places.bin")
    write_header(places, args.header_dir / "places_info.h")

    print("\nDone! Next steps:")
    print("  1. Upload places.bin to ESP32 LittleFS: pio run -t uploadfs")
    print("  2. Include places_info.h in your ESP32 code")

    return 0


if __name__ == "__main__":
    sys.exit(main())
